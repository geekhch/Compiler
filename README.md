# Complier
编译原理课程设计

`g++ run.cpp LexPaser.cpp -o a.exe`

## 词法分析器
### V 1.0
1. 完成词法分析的基本功能,将规定C-代码解析为tokens
2. 调用接口：`printTokenList()`、`nextToken()`
3. 实现算法：正则表达式 -> NFA -> 对应逻辑代码 (规定C-语法过于简单，后期迭代考虑实现更复杂语法解析)

## 语法分析(一)：递归下降
### 思路
1. 对于每个具有选择和循环的非终结符，使用marker标记当前token-list的位置，匹配失败时回退
2. 如果当前产生式匹配失败，则不应该向父节点插入任何子节点，在当前函数异常处理中要清理掉落单的结点。
3. 所有非终结符匹配成功与否使用异常表示（方便函数调用逻辑），所有终结符匹配成功与否使用`match()`函数的布尔返回值表示（方便实现条件选择）。
4. 非终结符的选择和循环条件由try-catch块实现(不是if-else)。
5. 所有非终结符匹配函数中只能向父结点最多插入一个节点（cur）,且插入操作应放在函数末尾（即匹配成功后才插入）
6. 所有选择关系都使用嵌套条件语句实现，有几个选择项就有几重嵌套
7. 对每一个异常都需要进行捕获并处理的原因是为了销毁当前函数下的对象，避免内存泄漏（否则只需要在终结符处抛出异常，只在顶层函数处理，倒是可以省下不少代码量）