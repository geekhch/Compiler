# Complier
编译原理课程设计

`g++ run.cpp LexPaser.cpp -o a.exe`

## 词法分析器
### V 1.0
1. 完成词法分析的基本功能,将规定C-代码解析为tokens
2. 调用接口：`printTokenList()`、`nextToken()`
3. 实现算法：正则表达式 -> NFA -> 对应逻辑代码 (规定C-语法过于简单，后期迭代考虑实现更复杂语法解析)

## 语法分析(一)：递归下降
### 思路
1. 对于每个具有选择和循环的非终结符，使用marker标记当前token-list的位置，匹配失败时回退
2. 如果当前产生式匹配失败，则不应该向父节点插入任何子节点，在当前函数异常处理中要清理掉落单的结点。
3. 所有非终结符匹配成功与否使用异常表示（方便函数调用逻辑），所有终结符匹配成功与否使用`match()`函数的布尔返回值表示（方便实现条件选择）。
4. 非终结符的选择和循环条件由try-catch块实现(不是if-else)。
5. 所有非终结符匹配函数中只能向父结点最多插入一个节点（cur）,且插入操作应放在函数末尾（即匹配成功后才插入）
6. 所有选择关系都使用嵌套条件语句实现，有几个选择项就有几重嵌套
7. 对每一个异常都需要进行捕获并处理的原因是为了销毁当前函数下的对象，避免内存泄漏（否则只需要在终结符处抛出异常，只在顶层函数处理，倒是可以省下不少代码量）
8. 对于expression产生式，由于左右两边有间接公共前缀，需要注意执行顺序（最长优先原则）
9. 析构函数中打印语法树，使用递归方式实现

## 语法分析(二)：LL(1)
### 步骤
1. 整理文法，消除左递归、去左公因子。
2. 每个非终结符对应多个产生式，每个产生式由多个元素（非终结符或终结符）构成。使用map<string, vector<vector<unit>>>保存所有文法。unit为一个终结符或非终结符单元。
3. 计算FIRST|FOLLOW集，生成预测分析表，预测分析表使用
4. 匹配终结符时，ID、NUM为特殊情况，需要对token类型进行判断，其他情况只需要判断token的串值。
5. expression的两条产生式含有间接公共左因子，不是LL(1)文法，需要进行改写（这一条极其恶心，嵌套深度太深了，复杂的语法耦合导致很难改写，先试着控制FIRST集计算过程，针对特定目标代码生成对应分析表，但必然存在隐藏bug,完全解决必须修正文法,其实上面的递归下降也一样有这个问题）

