#ifndef SYNTAX_PARSER_H
#define SYNTAX_PARSER_H
#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <fstream>
#include "LexParser.h"
using namespace std;

struct SynNode//语法树结点
{
    string word; //结点内容
    vector<SynNode*> child; //子节点(为空时表示根节点，即终结符)

    // SynNode(string s):word(s){}
};

class SynParser{
public:
    SynNode *root;
    SynNode *curNode;
    LexParser &lex;

private:
    void releaseTree(SynNode *root);

public:
    SynParser(LexParser &lex_):lex(lex_){
        root = new SynNode{"program"};
        curNode = root;
    }

    bool program(SynNode *node);
    bool declaration_list(SynNode *node);
    bool declaration(SynNode *node);
    bool var_declaration(SynNode *node);
    bool type_specifier(SynNode *node);
    bool fun_declaration(SynNode *node);
    bool params(SynNode *node);
    bool param_list(SynNode *node);
    bool param(SynNode *node);
    bool compound_stmt(SynNode *node);
    bool local_declarations(SynNode *node);
    bool statement_list(SynNode *node);
    bool statement(SynNode *node);
    bool expression_stmt(SynNode *node);
    bool selection_stmt(SynNode *node);
    bool iteration_stmt(SynNode *node);
    bool return_stmt(SynNode *node);
    bool expression(SynNode *node);
    bool var(SynNode *node);
    bool simple_expression(SynNode *node);
    bool relop(SynNode *node);
    bool additive_expression(SynNode *node);
    bool addop(SynNode *node);
    bool term(SynNode *node);
    bool mulop(SynNode *node);
    bool factor(SynNode *node);
    bool call(SynNode *node);
    bool args(SynNode *node);
    bool arg_list(SynNode *node);
};

#endif

bool SynParser::program(SynNode *root){ //构造函数时已将program作为根节点
    SynNode *child = new SynNode{"declaration_list"};
    if(declaration_list(child))
    {
        root->child.push_back(child);
        return true;
    }else{
        releaseTree(child);
        return false;
    }
}
bool SynParser::declaration_list(SynNode *node){
    SynNode *child = new SynNode{"declaration"};
    node->child.push_back(child);
    if(!declaration(child))
        return false;
    
    bool has_more = false;
    do{
        SynNode *child = new SynNode{"declaration"};
        has_more = declaration(child);
        if(has_more)
            node->child.push_back(child);
        else
            delete child;
    }while(has_more);
    return true;
}
bool SynParser::declaration(SynNode *node){
    SynNode *child_v = new SynNode{"var_declaration"};
    SynNode *child_f = new SynNode{"fun_declaration"};
    if(var_declaration(child_v)){
        node->child.push_back(child_v);
        return true;
    }else if(fun_declaration(child_f)){
        node->child.push_back(child_f);
        return true;
    }else
        return false;
}
bool SynParser::var_declaration(SynNode *node){}
// bool SynParser::type_specifier(SynNode *node){}
bool SynParser::fun_declaration(SynNode *node){}
// bool SynParser::params(SynNode *node){}
// bool SynParser::param_list(SynNode *node){}
// bool SynParser::param(SynNode *node){}
// bool SynParser::compound_stmt(SynNode *node){}
// bool SynParser::local_declarations(SynNode *node){}
// bool SynParser::statement_list(SynNode *node){}
// bool SynParser::statement(SynNode *node){}
// bool SynParser::expression_stmt(SynNode *node){}
// bool SynParser::selection_stmt(SynNode *node){}
// bool SynParser::iteration_stmt(SynNode *node){}
// bool SynParser::return_stmt(SynNode *node){}
// bool SynParser::expression(SynNode *node){}
// bool SynParser::var(SynNode *node){}
// bool SynParser::simple_expression(SynNode *node){}
// bool SynParser::relop(SynNode *node){}
// bool SynParser::additive_expression(SynNode *node){}
// bool SynParser::addop(SynNode *node){}
// bool SynParser::term(SynNode *node){}
// bool SynParser::mulop(SynNode *node){}
// bool SynParser::factor(SynNode *node){}
// bool SynParser::call(SynNode *node){}
// bool SynParser::args(SynNode *node){}
// bool SynParser::arg_list(SynNode *node){}

void SynParser::releaseTree(SynNode *root){
    if(root->child.empty())
        delete root;
    else{
        for(auto node: root->child){
            releaseTree(node);
        }
    }
}